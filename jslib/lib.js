/* Generated by GoScript (github.com/kless/goscript) */







var g = {}; (function() {


const 
invalidT = 0,
arrayT = 1,
mapT = 2,
sliceT = 3;





(function() {


	if (!Array.isArray) {
		Array.isArray = function(arg) {
			return Object.prototype.toString.call(arg) === "[object Array]";
		};
	}
}());





function arrayType(v, len_) {
	this.v=v;

	this.len_=len_
}


arrayType.prototype.len = function(dim) {
	if (dim === undefined) {
		return this.len_[0];
	}
	return this.len_[arguments.length];
}


arrayType.prototype.cap = function(dim) {
	if (dim === undefined) {
		return this.len_[0];
	}
	return this.len_[arguments.length];
}


arrayType.prototype.typ = function() { return arrayT; }



function MkArray(dim, zero, data) {
	var a = new arrayType([], g.Map(0));

	if (data !== undefined) {
		if (!equalDim(dim, getDimArray(data))) {
			a.v = initArray(dim, zero);
			mergeArray(a.v, data);
		} else {
			a.v = data;
		}
	} else {
		a.v = initArray(dim, zero);
	}

	var v; for (var i in dim) { v = dim[i];
		a.len_[i] = v;
	}

	return a;
}




function equalDim(d1, d2) {
	if (d1.length !== d2.length) {
		return false;
	}
	var v; for (var i in d1) { v = d1[i];
		if (JSON.stringify(v) !== JSON.stringify(d2[i])) {
			return false;
		}
	}
	return true;
}


function getDimArray(a) { var dim = [];
	for (;;) {
		dim.push(a.length);

		if (Array.isArray(a[0])) {
			a = a[0];
		} else {
			break;
		}
	}
	return dim;
}


function initArray(dim, zero) { var a = [];
	if (dim.length === 0) {
		return zero;
	}
	var nextArray = initArray(dim.slice(1), zero);

	for (var i = 0; i < dim[0]; i++) {
		a[i] = nextArray;
	}
	return a;
}


function mergeArray(dst, src) {
	var srcVal; for (var i in src) { srcVal = src[i];
		if (Array.isArray(srcVal)) {
			mergeArray(dst[i], srcVal);
		} else {
			var isHashMap = false;


			if (typeof(srcVal) === "object") {
				var v; for (var k in srcVal) { v = srcVal[k];
					if (srcVal.hasOwnProperty(k)) {
						isHashMap = true;
						i = k;
						dst[i] = v;
					}
				}
			}
			if (!isHashMap) {
				dst[i] = srcVal;
			}
		}
	}
}





function sliceType(arr, v, low, high, len, cap, nil_) {
	this.arr=arr;
	this.v=v;

	this.low=low;
	this.high=high;
	this.len=len;
	this.cap=cap;

	this.nil_=nil_
}


sliceType.prototype.typ = function() { return sliceT; }

sliceType.prototype.isNil = function() {
	if (this.len !== 0 || this.cap !== 0) {
		return false;
	}
	return this.nil_;
}


function MkSlice(zero, len, cap) {
	var s = new sliceType(undefined, [], 0, 0, 0, 0, false);

	if (zero === undefined) {
		s.nil_ = true;
		return s;
	}

	s.len = len;

	for (var i = 0; i < len; i++) {
		s.v[i] = zero;
	}
	if (cap !== undefined) {
		s.cap = cap;
	} else {
		s.cap = len;
	}
	return s;
}


function Slice(zero, data) {
	var s = new sliceType(undefined, [], 0, 0, 0, 0, false);

	if (arguments.length === 0) {
		s.nil_ = true;
		return s;
	}

	var srcVal; for (var i in data) { srcVal = data[i];
		var isHashMap = false;


		if (typeof(srcVal) === "object") {
			var v; for (var k in srcVal) { v = srcVal[k];
				if (srcVal.hasOwnProperty(k)) {
					isHashMap = true;

					for (i; i < k; i++) {
						s.v[i] = zero;
					}
					s.v[i] = v;
				}
			}
		}
		if (!isHashMap) {
			s.v[i] = srcVal;
		}
	}

	s.len = s.v.length;
	s.cap = s.len;
	return s;
}


function SliceFrom(a, low, high) {
	var s = new sliceType(undefined, [], 0, 0, 0, 0, false);

	s.arr = a;
	s.low = low;
	s.high = high;
	s.len = high - low;
	s.cap = a.cap - low;
	return s;
}


sliceType.prototype.set = function(i, low, high) {
	this.low = low, this.high = high;

	if (JSON.stringify(i.typ()) === JSON.stringify(arrayT)) {
		this.arr = i;
		this.len = high - low;
		this.cap = i.cap() - low;
		this.v = i.v.slice(low, high);

	} else {
		if (i.v.length !== 0) {
			this.v = i.v.slice(low, high);
		} else {
			this.v = i.arr.v.slice(low, high);
		}
		this.cap = i.cap - low;
		this.len = this.v.length;
	}











}











sliceType.prototype.str = function() {


	return this.v.join("");
}



































function mapType(v, zero) {
	this.v=v;
	this.zero=zero
}


mapType.prototype.len = function() {
	var len = 0;
	var _; for (var key in this.v) { _ = this.v[key];
		if (this.v.hasOwnProperty(key)) {
			len++;
		}
	}
	return len;
}


mapType.prototype.typ = function() { return mapT; }


function Map(zero, v) {
	var m = new mapType(v, zero);
	return m;
}




mapType.prototype.get = function(k) {
	var v = this.v;


	for (var i = 0; i < arguments.length; i++) {
		v = v[arguments[i]];
	}

	if (v === undefined) {
		return [this.zero, false];
	}
	return [v, true];
}





function Export(pkg, exported) {
	var v; for (var _ in exported) { v = exported[_];
		pkg.v = v;
	}
}

g.MkArray = MkArray;
g.MkSlice = MkSlice;
g.Slice = Slice;
g.SliceFrom = SliceFrom;
g.Map = Map;
g.Export = Export;

})();
